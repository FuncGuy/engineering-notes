Attitude of honesty, honor, self respect, and pride. A willingness to accept the dire responsability of a craftamen and an engineer. Working well and Working clean. Communicating well. Estimating faithfully.



Law of Leaky Abstractions
-------------------------
[by spolosky]: Law of Leaky Abstractions:

All non-trivial abstractions, to some degree, are leaky.
Abstractions fail. Sometimes a little, sometimes a lot. There's leakage. Things go wrong. It happens all over the place when you have abstractions. One reason the law of leaky abstractions is problematic is that it means that abstractions do not really simplify our lives as much as they were meant to. The only way to deal with the leaks competently is to learn about how the abstractions work and what they are abstracting. So the abstractions save us time working, but they don't save us time learning.

----

Operating in a difficult domain (e.g., compilers, language workbenches, ...) does not mean software design is less important. A difficult domain, still need to talk about stuff like how to propagate errors, exception, livetime of objects, who is repsonsible for what... Even in a difficult domain, you need to break your problem down into pieces. Then it won't be difficult any more and you can attack it.

----

Conway's law is an adage named after computer programmer Melvin Conway, who introduced the idea in 1968; it was first dubbed Conway's law by participants at the 1968 National Symposium on Modular Programming.[1] It states that
organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations
—M. Conway[2]

Eric S Raymond: If you have four groups working on a compiler, you'll get a 4-pass compiler

------------

# Stuff to look at

* fault tolerance in erlang: What can we learn? What can we adopt?
* review notes on para alg and para prog
* malleable task. do some research...
* what does google say about centralised control???
* Solid principles, component principle,
* list of useful diagrams and when to use them (dfd, Feature, fmc,...),

----------------

## Sources to review
* Study notes
    - Compiler Construction
    - Experimental Economics: Design Elements (e.g., baseline neighborhood) and the basic idea of falsification as supplement material for the algorithm engineering notes
    - Formal Systems (something in there?)
    - ~~Advanced Data Structures~~
    - Parallel Algorithms
    - Parallel Machines and Parallel Programming
    - Randomized Algorithms
    - Computerarchitecture (implications of branch predictions, cache coherence, pipelining, super scalar architecutures ...)
    - Softwareengineering II
    - Game Theory (Battle of the sexes :p)
* Lecture notes and books to skim
    - Algorithm Engineering
    - Algorithm II
    - Algorithms and Data Structures — The Basic Toolbox
    - Linder's _Things Thy Should have taught you_
* Books with potential:
    - Pragmatic Thinking and Learning
    - Notes from the Pragmatic Programmer
    - Notes from Head First Software Development (Very light stuff but maybe there is something in there. I used to enjoy reading it.)
    - ...
